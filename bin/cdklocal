#!/usr/bin/env node

const provider = require('aws-cdk/lib/api/aws-auth/sdk-provider');
const { CdkToolkit } = require('aws-cdk/lib/cdk-toolkit');
const { SDK } = require('aws-cdk/lib/api/aws-auth/sdk');
const { ToolkitInfo }  = require('aws-cdk/lib/api');
const deployStackMod = require('aws-cdk/lib/api/deploy-stack');
const {
  BUCKET_NAME_OUTPUT, BUCKET_DOMAIN_NAME_OUTPUT
} = require("aws-cdk/lib/api/bootstrap/bootstrap-props");
const { FileAssetHandler } = require('aws-cdk/node_modules/cdk-assets/lib/private/handlers/files');

const DEFAULT_EDGE_PORT = 4566;
const DEFAULT_HOSTNAME = 'localhost';
const LAMBDA_MOUNT_CODE = ['1', 'true'].includes(process.env.LAMBDA_MOUNT_CODE);


//----------------
// UTIL FUNCTIONS
//----------------

const getLocalEndpoint = () => `http://${getLocalHost()}`;

const port = process.env.EDGE_PORT || DEFAULT_EDGE_PORT;

const getLocalHost = () => {
  const host = process.env.LOCALSTACK_HOSTNAME || DEFAULT_HOSTNAME;
  return `${host}:${port}`;
};

const useLocal = (options) => {
  // TODO make configurable..?
  return true;
};

const setOptions = (options, setHttpOptions) => {
  if (!useLocal(options)) return;
  if (setHttpOptions) {
    options = options.httpOptions = options.httpOptions || {};
  }
  options.endpoint = getLocalEndpoint();
  options.s3ForcePathStyle = true;
  options.accessKeyId = 'test';
  options.secretAccessKey = 'test';
};

const getMethods = (obj) => {
  let properties = new Set();
  let currentObj = obj;
  do {
    Object.getOwnPropertyNames(currentObj).map(item => properties.add(item));
  } while ((currentObj = Object.getPrototypeOf(currentObj)));
  const excluded = [
    'caller', 'callee', 'arguments', 'constructor', 'isPrototypeOf',
    'hasOwnProperty', 'valueOf', 'toString', 'toLocaleString', 'propertyIsEnumerable'
  ];
  const props = [...properties.keys()].filter(p => !excluded.includes(p) && !p.startsWith('__'));
  return props.filter(item => typeof obj[item] === 'function')
}

//---------
// PATCHES
//---------

const origConstr = provider.SdkProvider.withAwsCliCompatibleDefaults;
provider.SdkProvider.withAwsCliCompatibleDefaults = async (options = {}) => {
  setOptions(options, true);
  return origConstr(options);
};

provider.SdkProvider.prototype.defaultCredentials = () => {
  return {
    accessKeyId: process.env.AWS_ACCESS_KEY_ID || 'test',
    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY || 'test'
  };
};

const currentAccount = SDK.prototype.currentAccount;
SDK.prototype.currentAccount = async function () {
  const config = this.config;
  setOptions(config);
  return currentAccount.bind(this)();
};

const forceCredentialRetrieval = SDK.prototype.forceCredentialRetrieval;
SDK.prototype.forceCredentialRetrieval = async function () {
  if (!this._credentials.getPromise) {
    this._credentials.getPromise = () => this._credentials;
  }
  return forceCredentialRetrieval.bind(this)();
};

getMethods(CdkToolkit.prototype).forEach(meth => {
  const original = CdkToolkit.prototype[meth];
  CdkToolkit.prototype[meth] = function() {
    setOptions(this.props.sdkProvider.sdkOptions);
    return original.bind(this).apply(this, arguments);
  }
});

function setBucketUrl(object) {
  Object.defineProperty(object, 'bucketUrl', {
    get() {
      const bucket = this.requireOutput(BUCKET_NAME_OUTPUT);
      const domain = this.requireOutput(BUCKET_DOMAIN_NAME_OUTPUT) || getLocalHost();
      return `https://${domain.replace(`${bucket}.`, '')}:${port}/${bucket}`
    }
  });
}

// for compatibility with with older versions of CDK
setBucketUrl(ToolkitInfo.prototype);

const cdkLookupFn = ToolkitInfo.lookup
ToolkitInfo.lookup = async function(...args) {
  const toolkitInfoObject = await cdkLookupFn(...args);
  setBucketUrl(toolkitInfoObject);
  return toolkitInfoObject;
}

const fromStackFn = ToolkitInfo.fromStack
ToolkitInfo.fromStack = function(...args) {
  const toolkitInfoObject = fromStackFn(...args);
  setBucketUrl(toolkitInfoObject);
  return toolkitInfoObject;
}

// modify asset paths to enable local Lambda code mounting

const deployStackOrig = deployStackMod.deployStack;
deployStackMod.deployStack = async function deployStack(options) {
  options.sdk.cloudFormationOrig = options.sdk.cloudFormationOrig || options.sdk.cloudFormation;
  const state = {};
  options.sdk.cloudFormation = function() {
    return state.instance;
  }
  const cfn = state.instance = options.sdk.cloudFormationOrig();
  cfn.createChangeSetOrig = cfn.createChangeSetOrig || cfn.createChangeSet;
  cfn.createChangeSet = function(params) {
    if (LAMBDA_MOUNT_CODE) {
      (params.Parameters || []).forEach((item) => {
        // TODO: create a more resilient lookup mechanism (not based on 'S3Bucket' param key) below!
        if (item.ParameterKey.includes('S3Bucket')) {
          item.ParameterValue = '__local__';
        }
        const parts = item.ParameterValue.split('||');
        if (item.ParameterKey.includes('S3VersionKey') && item.ParameterValue.endsWith('.zip') && parts.length > 1) {
          item.ParameterValue = `${process.cwd()}/||cdk.out/asset.${parts[1].replace('.zip', '')}`;
        }
      });
    }
    return cfn.createChangeSetOrig(params)
  };
  const result = deployStackOrig(options);
  return result;
}

const handlerPublish = FileAssetHandler.prototype.publish;
FileAssetHandler.prototype.publish = async function() {
  if (LAMBDA_MOUNT_CODE && this.asset.destination && this.asset.source) {
    if (this.asset.source.packaging === 'zip') {
      // skip uploading this asset - should get mounted via `__file__` into the Lambda container later on
      return;
    }
  }
  return handlerPublish.bind(this)();
};

//----------
// MAIN CLI
//----------

require('aws-cdk/bin/cdk');
